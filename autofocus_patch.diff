*** Begin Patch
*** Update File: autofocus.cpp
@@
 void AutoFocus::processCoarseAdjustment()
 {
-    // 立即检查运行状态，如果已停止则直接返回
-    if (!m_isRunning) {
-        log("自动对焦已停止，跳过粗调");
-        return;
-    }
-    
-    // 检查是否收集了足够的数据点
-    if (m_dataCollectionCount >= g_autoFocusConfig.minDataPoints) {
-        log(QString("粗调数据收集完成，开始拟合"));
-        changeState(AutoFocusState::FITTING_DATA);
-        return;
-    }
-
-    // 移动电调到下一个位置
-    moveFocuser(m_coarseStepSize);
-    
-    // 设置等待电调移动完成的状态
-    if (m_isFocuserMoving) {
-        log(QString("电调开始移动，等待移动完成"));
-        m_waitingForMove = true;
-        m_moveWaitStartTime = QDateTime::currentMSecsSinceEpoch();
-        m_moveWaitCount = 0;
-        m_moveLastPosition = m_currentPosition;
-        // 目标位置已经在moveFocuser中设置，这里不需要重复设置
-        return; // 返回，让定时器处理等待
-    }
-    
-    // 电调没有移动，直接进行拍摄
-    log(QString("电调无需移动，直接进行拍摄"));
-    
-    // 执行粗调数据收集逻辑
-    performCoarseDataCollection();
+    // **符合需求：粗调阶段不进行拟合，只寻找最小FWHM并移动过去**
+    if (!m_isRunning) {
+        log("自动对焦已停止，跳过粗调");
+        return;
+    }
+
+    // 正在等待移动完成时，等待分支会在 processCurrentState() 中处理，避免重复触发
+    if (m_waitingForMove || m_isFocuserMoving) {
+        return;
+    }
+
+    // 直接执行一次采样/推进逻辑（performCoarseDataCollection 会负责：
+    // 1) 在必要时下发下一次 beginMoveTo；
+    // 2) 在收尾时移动到 coarse 最优点并切换到精调状态）。
+    performCoarseDataCollection();
 }
@@
 void AutoFocus::processFineAdjustment()
 {
-    // 立即检查运行状态，如果已停止则直接返回
-    if (!m_isRunning) {
-        log("自动对焦已停止，跳过精调");
-        return;
-    }
-    
-    // 检查是否收集了足够的数据点
-    if (m_dataCollectionCount >= g_autoFocusConfig.minDataPoints) {
-        log(QString("精调数据收集完成，开始拟合"));
-        changeState(AutoFocusState::FITTING_DATA);
-        return;
-    }
-
-    // 移动电调到下一个位置
-    moveFocuser(m_fineStepSize);
-    
-    // 设置等待电调移动完成的状态
-    if (m_isFocuserMoving) {
-        log(QString("电调开始移动，等待移动完成"));
-        m_waitingForMove = true;
-        m_moveWaitStartTime = QDateTime::currentMSecsSinceEpoch();
-        m_moveWaitCount = 0;
-        m_moveLastPosition = m_currentPosition;
-        // 目标位置已经在moveFocuser中设置，这里不需要重复设置
-        return; // 返回，让定时器处理等待
-    }
-    
-    // 电调没有移动，直接进行拍摄
-    log(QString("电调无需移动，直接进行拍摄"));
-    
-    // 执行精调数据收集逻辑
-    performFineDataCollection();
+    // **符合需求：精调阶段进行数据拟合**
+    if (!m_isRunning) {
+        log("自动对焦已停止，跳过精调");
+        return;
+    }
+
+    // 正在等待移动完成时，等待分支会在 processCurrentState() 中处理
+    if (m_waitingForMove || m_isFocuserMoving) {
+        return;
+    }
+
+    // 由 performFineDataCollection 负责推进采样序列；
+    // 当采样完成后它会自动切换到 FITTING_DATA 进入拟合阶段。
+    performFineDataCollection();
 }
@@
 void AutoFocus::completeAutoFocus(bool success)
 {
-    try {
-        log(QString("开始完成自动对焦流程，成功状态: %1").arg(success ? "是" : "否"));
-        
-        m_isRunning = false;
-        
-        // 安全停止定时器
-        if (m_timer && m_timer->isActive()) {
-            m_timer->stop();
-            log("定时器已停止");
-        }
-        
-        if (success) {
-            double bestPosition = 0.0;
-            double minHFR = 0.0;
-            
-            // 安全访问数据
-            if (!m_focusData.isEmpty()) {
-                bestPosition = m_focusData.last().focuserPosition;
-                minHFR = m_focusData.last().hfr;
-            }
-            
-            emit autoFocusCompleted(true, bestPosition, minHFR);
-            log("自动对焦完成");
-        } else {
-            emit autoFocusCompleted(false, 0.0, 0.0);
-            log("自动对焦失败");
-        }
-        
-        changeState(AutoFocusState::COMPLETED);
-        log("自动对焦流程完成");
-        
-    } catch (const std::exception& e) {
-        log(QString("完成自动对焦时发生异常: %1").arg(e.what()));
-    } catch (...) {
-        log("完成自动对焦时发生未知异常");
-    }
+    try {
+        log(QString("开始完成自动对焦流程，成功状态: %1").arg(success ? "是" : "否"));
+
+        m_isRunning = false;
+
+        // 安全停止定时器
+        if (m_timer && m_timer->isActive()) {
+            m_timer->stop();
+            log("定时器已停止");
+        }
+
+        if (success) {
+            // 优先使用精调拟合得到的结果；否则退回到粗调阶段的最优点；再否则退回到最后一次数据。
+            double bestPosition = 0.0;
+            double minHFR = 0.0;
+
+            const bool hasFit = (m_lastFitResult.a != 0.0 || m_lastFitResult.b != 0.0 || m_lastFitResult.c != 0.0);
+            if (hasFit) {
+                bestPosition = m_lastFitResult.bestPosition;
+                minHFR      = m_lastFitResult.minHFR;
+            } else if (std::isfinite(m_coarseBestFWHM)) {
+                bestPosition = m_coarseBestPosition;
+                minHFR      = m_coarseBestFWHM;
+            } else if (!m_focusData.isEmpty()) {
+                bestPosition = m_focusData.last().focuserPosition;
+                minHFR      = m_focusData.last().hfr;
+            }
+
+            emit autoFocusCompleted(true, bestPosition, minHFR);
+            log(QString("自动对焦完成：best=%1, FWHM=%2").arg(bestPosition).arg(minHFR));
+        } else {
+            emit autoFocusCompleted(false, 0.0, 0.0);
+            log("自动对焦失败");
+        }
+
+        changeState(AutoFocusState::COMPLETED);
+        log("自动对焦流程完成");
+
+    } catch (const std::exception& e) {
+        log(QString("完成自动对焦时发生异常: %1").arg(e.what()));
+    } catch (...) {
+        log("完成自动对焦时发生未知异常");
+    }
 }
*** End Patch